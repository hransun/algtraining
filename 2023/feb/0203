60. 数组去重
 ___       _   _____                                    
(  _`\  _ ( )_(_   _)_                         _        
| (_) )(_)| ,_) | | (_)   __     __   _ __    (_)   _   
|  _ <'| || |   | | | | /'_ `\ /'__`\( '__)   | | /'_`\
| (_) )| || |_  | | | |( (_) |(  ___/| |    _ | |( (_) )
(____/'(_)`\__) (_) (_)`\__  |`\____)(_)   (_)(_)`\___/'
                       ( )_) |                          
                        \___/'     
题目描述
给你一个排好序的数组，请基于当前数组去除所有重复的元素。
输入输出
输入
•	第一行是n，表示数组有n个元素；当n=-1，表示输入结束
•	第二行是n个排序好的整数
输出
•	针对每组输入，输出去重后的数组
示例输入
5
1 2 2 3 3
-1
示例输出
1 2 3


61. 数组去重II
 ___       _   _____                                    
(  _`\  _ ( )_(_   _)_                         _        
| (_) )(_)| ,_) | | (_)   __     __   _ __    (_)   _   
|  _ <'| || |   | | | | /'_ `\ /'__`\( '__)   | | /'_`\
| (_) )| || |_  | | | |( (_) |(  ___/| |    _ | |( (_) )
(____/'(_)`\__) (_) (_)`\__  |`\____)(_)   (_)(_)`\___/'
                       ( )_) |                          
                        \___/'     
题目描述
给你一个排好序的数组，请基于当前数组保证每个元素最多出现k次（移除多余的出现）。
输入输出
输入
•	第一行是n，表示数组有n个元素；当n=-1，表示输入结束
•	第二行是k
•	第三行是n个排序好的整数
输出
•	针对每组输入，输出去重后的数组
示例输入
10
3
1 1 1 1 2 2 2 2 4 4
-1
示例输出
1 1 1 2 2 2 4 4

62. 设计LRU Cache
 ___       _   _____                                    
(  _`\  _ ( )_(_   _)_                         _        
| (_) )(_)| ,_) | | (_)   __     __   _ __    (_)   _   
|  _ <'| || |   | | | | /'_ `\ /'__`\( '__)   | | /'_`\
| (_) )| || |_  | | | |( (_) |(  ___/| |    _ | |( (_) )
(____/'(_)`\__) (_) (_)`\__  |`\____)(_)   (_)(_)`\___/'
                       ( )_) |                          
                        \___/'     
题目描述
请设计一个LRU的Cache
输入输出
输入
•	第一行是n，表示cache的大小；当n=-1时，表示输入结束
•	第二行是k，表示有k次操作
•	之后的k行，每行是一个操作：当操作是SET时，之后的两个整数表示key和value；当操作是SET时，之后的整数表示key
输出
•	针对每一个GET，输出这个key对应的value，如果key不存在输出null
示例输入
2
6
SET 1 2
SET 2 3
SET 3 5
SET 4 6
GET 2
GET 3
-1
示例输出
null
5

63. 公共祖先
 ___       _   _____                                    
(  _`\  _ ( )_(_   _)_                         _        
| (_) )(_)| ,_) | | (_)   __     __   _ __    (_)   _   
|  _ <'| || |   | | | | /'_ `\ /'__`\( '__)   | | /'_`\
| (_) )| || |_  | | | |( (_) |(  ___/| |    _ | |( (_) )
(____/'(_)`\__) (_) (_)`\__  |`\____)(_)   (_)(_)`\___/'
                       ( )_) |                          
                        \___/'     
题目描述
寻找一个二叉树中两个节点的最小公共祖先。
https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        return find(root,p,q);
    }

    public TreeNode find(TreeNode node, TreeNode p,TreeNode q) {
        // base case
        if  (node == p || node == q || node == null) return node;
        TreeNode left_find = find(node.left,p,q);
        TreeNode right_find = find(node.right,p,q);
        // if left and right then return current node
        if (left_find != null && right_find != null) return node;
        if (left_find != null ) return left_find;
        else {
            return right_find;
        }


    }
}


    0
   /  \
  1    2
 / \  /
3  4 5
  / \
 6  7
要求：
•	请使用以下的树形结构
class Node{
  int id;
  Node left;
  Node right;
}
输入输出
输入
•	第一行是n，表示树的n个元素；当n=-1，表示输入结束
•	之后的n行表示编号从0到n-1的节点，每个节点包括两个整数：左子树的编号、右子树的编号（编号-1表示空节点）
•	第n+2行是m，表示要查询的节点对的个数
•	之后的m行，每行是两个节点的编号
输出
•	针对每对要查询的节点，输出它们的最小公共祖先。
示例输入
8
1 2
3 4
5 -1
-1 -1
6 7
-1 -1
-1 -1
-1 -1
3
6 3
2 5
2 7
-1
示例输出
1
2
0

64. 树的三种遍历
 ___       _   _____                                    
(  _`\  _ ( )_(_   _)_                         _        
| (_) )(_)| ,_) | | (_)   __     __   _ __    (_)   _   
|  _ <'| || |   | | | | /'_ `\ /'__`\( '__)   | | /'_`\
| (_) )| || |_  | | | |( (_) |(  ___/| |    _ | |( (_) )
(____/'(_)`\__) (_) (_)`\__  |`\____)(_)   (_)(_)`\___/'
                       ( )_) |                          
                        \___/'     
题目描述
请实现一棵二叉树的先根、中根、后根遍历。
    0
   /  \
  1    2
 / \  /
3  4 5
  / \
 6  7
输入输出
输入
•	第一行是n，表示树的n个元素；当n=-1，表示输入结束
•	之后的n行表示编号从0到n-1的节点，每个节点包括三个整数：这个节点的数值、左子树的编号、右子树的编号（编号-1表示空节点）
输出
•	针对每棵树，分别输出它的先根、中根、后根的遍历结果。
示例输入
8
0 1 2
1 3 4
2 5 -1
3 -1 -1
4 6 7
5 -1 -1
6 -1 -1
7 -1 -1
-1
示例输出
0 1 3 4 6 7 2 5
3 1 6 4 7 0 5 2
3 6 7 4 1 5 2 0

67. 树的三种遍历II
 ___       _   _____                                    
(  _`\  _ ( )_(_   _)_                         _        
| (_) )(_)| ,_) | | (_)   __     __   _ __    (_)   _   
|  _ <'| || |   | | | | /'_ `\ /'__`\( '__)   | | /'_`\
| (_) )| || |_  | | | |( (_) |(  ___/| |    _ | |( (_) )
(____/'(_)`\__) (_) (_)`\__  |`\____)(_)   (_)(_)`\___/'
                       ( )_) |                          
                        \___/'     
题目描述
请使用iteration的方法实现一棵二叉树的先根、中根、后根遍历。
    0
   /  \
  1    2
 / \  /
3  4 5
  / \
 6  7
输入输出
输入
•	第一行是n，表示树的n个元素；当n=-1，表示输入结束
•	之后的n行表示编号从0到n-1的节点，每个节点包括三个整数：这个节点的数值、左子树的编号、右子树的编号（编号-1表示空节点）
输出
•	针对每棵树，分别输出它的先根、中根、后根的遍历结果。
示例输入
8
0 1 2
1 3 4
2 5 -1
3 -1 -1
4 6 7
5 -1 -1
6 -1 -1
7 -1 -1
-1
示例输出
0 1 3 4 6 7 2 5
3 1 6 4 7 0 5 2
3 6 7 4 1 5 2 0
