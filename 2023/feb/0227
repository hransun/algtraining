https://leetcode.com/problems/largest-rectangle-in-histogram/

class Solution {
    public int largestRectangleArea(int[] array) {
        if (array == null || array.length == 0) return 0;
        // a list to impl deque and save index in the deque
        Deque<Integer> stack = new LinkedList<>();
        int max = 0;
        for (int i = 0; i <= array.length; i++) {
            // in the end put a wall to pop everything
            int curVal = i == array.length ? 0 : array[i];
            // index in the deque
            while (!stack.isEmpty() && array[stack.peekLast()] >= curVal) {
                int height = array[stack.pollLast()];
                // second to the last because the one already pop
                int leftBound = stack.isEmpty()? 0: stack.peekLast() + 1 ;
                int rightBound = i;
                max = Math.max(max,height * (rightBound - leftBound ));
            }
            stack.addLast(i);
        }
        return max;
        
    }
}

https://leetcode.com/problems/trapping-rain-water/

class Solution {
    public int trap(int[] height) {
        if (height.length == 0) return 0;
        Deque<Integer> stack = new LinkedList<>();
        int sum = 0;

        // should decrease then you can hold water
        for (int i = 0; i < height.length; i++) {
            int cur = height[i];
            while (!stack.isEmpty() && height[stack.peekLast()] < cur) {
                int index = stack.pollLast();
                if (!stack.isEmpty()) {
                    int rightBound = i;
                    int leftBound = stack.peekLast();
                    sum += (rightBound - leftBound  - 1 ) *
                            (Math.min(cur,height[leftBound]) - height[index]);
                }

            }
            stack.offerLast(i);
        }
        return sum;
        
    }
}

