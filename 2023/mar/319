https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/

class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        if (nums == null || nums.length ==0) return null;
        return buildtree(nums,0, nums.length-1);

        
    }
    private TreeNode buildtree(int[] nums,int start, int end) {
        if (start > end) return null;
        int mid = (start + end) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = buildtree(nums,start, mid -1);
        root.right =  buildtree(nums,mid+1,end);
        return root;
    }
}


https://leetcode.com/problems/spiral-matrix/

class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList<>();
        if (matrix== null || matrix.length == 0) {
            return res;
        }
        if (matrix[0] == null || matrix[0].length ==0) return res;
        int row = matrix.length;
        int col = matrix[0].length;
        helper(res,matrix,row,col,0);
        return res;

    }

    private void helper(List<Integer> res , int[][] matrix,int row, int  col , int offset) {
        // base case
        if (row ==0|| col ==0) {
        return;
        }
        if (row == 1) {
            // only 1 row

            for (int i = offset; i <col + offset ; i++) {
                res.add(matrix[offset][i]);
            }
            return;
        }
        if (col ==1) {
            // only 1 col
            for (int i = offset; i <row + offset ; i++) {
                res.add(matrix[i][offset]);

            }
            return;
        }
        // 1 .  up row
        // col -1 not include last col
        // offset means shift right
        for (int i = offset; i <col-1 + offset ; i++) {
            res.add(matrix[offset][i]);
        }
        // right col
        for (int i = offset; i <row - 1+ offset ; i++) {
            res.add(matrix[i][col-1+offset]);
        }
        // bottom row
        for (int i = col-1 + offset; i > offset ; i--) {
            res.add(matrix[row - 1+offset][i]);
        }
        // left col
        for (int i = row-1 + offset; i > offset; i--) {
            res.add(matrix[i][offset]);
        }
        helper(res,matrix,row - 2,col -2,offset +1);
    }
}


https://leetcode.com/problems/spiral-matrix-ii/

class Solution {
    public int[][] generateMatrix(int n) {
        if (n <=0) return new int[0][0];
        int cur[] = {0};
        int[][] res = new int[n][n];
        helper(res,cur,n,0);
        return res;
        
    }
    // global res
    private void helper(int[][] res , int[] cur, int size,int offset) {
        // base case
        if (size ==0) return;
        if (size == 1) {
            res[offset][offset] = ++cur[0];
            return;
        }
        // 1, first row size -1 + offset - offset
        for (int i = offset; i <size -1 + offset ; i++) {
            res[offset][i] = ++cur[0]; // start from 1
        }
        // 2, right col
        for (int i = offset; i <size -1 + offset ; i++) {
            res[i][size-1+offset] = ++cur[0];
        }
        // 3, bottom row
        for (int i = size -1 + offset; i > offset ; i--) {
            res[size-1+offset][i] = ++cur[0];
        }
        // 4 first col
        for (int i = size-1+offset; i > offset ; i--) {
            res[i][offset] = ++cur[0];
        }
        helper(res,cur,size-2,offset+1);
    }
}

https://leetcode.com/problems/sort-an-array/ merge sort 

class Solution {
    public int[] sortArray(int[] nums) {
        if (nums == null) return nums;
        int[] helper = new int[nums.length];
        doSort(nums,helper,0,nums.length-1);
        return nums;
        
    }
    private void doSort(int[] nums,int[] helper, int start, int  end) {
        if (start >= end) return; // until one element return
        int mid = (start + end) / 2;
        doSort(nums,helper,start,mid);
        doSort(nums,helper,mid+1,end);
        merge(nums,helper,start,mid,end);
    }

    private void merge(int[] nums,int[] helper,int aStart, int aEnd , int bEnd) {
        // copy processing data to tmp array
        for (int i = aStart; i <= bEnd ; i++) {
            helper[i] = nums[i];
        }
        // merge sort these data
        int aCur = aStart;
        int bCur = aEnd+1;
        for (int i = aStart; i <=bEnd ; i++) {
            if (aCur > aEnd) {
                nums[i] = helper[bCur++];
            } else if (bCur > bEnd) {
                nums[i] = helper[aCur++];
            } else if (helper[aCur] <= helper[bCur]) {
                nums[i] = helper[aCur++];
            } else {
                nums[i] = helper[bCur++];
            }

        }

    }
}


https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/

class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>() ;
        if (root== null) return res;
        Deque<TreeNode> deque = new LinkedList<>();
        boolean flag = true;
        deque.add(root);
        while(!deque.isEmpty()) {
            int size = deque.size();
            List<Integer> list = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                if (flag) {
                    // left to right
                    TreeNode cur = deque.pollFirst();
                    list.add(cur.val);
                    // next level right to left
                    if (cur.left != null) {
                        deque.offerLast(cur.left);
                    }
                    if (cur.right!= null) {
                        deque.offerLast(cur.right);
                    }
                } else {
                    // right to left
                    TreeNode cur = deque.pollLast();
                    list.add(cur.val);
                    if (cur.right != null) {
                        deque.offerFirst(cur.right);
                    }
                    if (cur.left != null) {
                        deque.offerFirst(cur.left);
                    }
                }

            }
            flag = flag ? false: true;
            res.add(list);

        }
        return res;
    }
}

https://leetcode.com/problems/path-sum/

class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) return false;

        int sum = targetSum - root.val;
        if (root.left == null && root.right == null  ) {
            return sum==0;
        }
        return  (hasPathSum(root.left,sum) || hasPathSum(root.right,sum));
    }
}
#  https://leetcode.com/problems/path-sum-ii/
#  https://leetcode.com/problems/path-sum-iii/
https://leetcode.com/problems/path-sum-iv/
https://leetcode.com/problems/binary-tree-maximum-path-sum/

# delete node in a BST
# https://leetcode.com/problems/delete-node-in-a-bst/
# largest bst subtree
# https://leetcode.com/problems/largest-bst-subtree/
